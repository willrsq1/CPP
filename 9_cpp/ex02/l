### COMPILATION ###

CC      = c++
FLAGS   = -Wall -Wextra -Werror -fsanitize=address

### EXECUTABLE ###

NAME    = PmergeMe

### SOURCE FILES ###

SOURCES =	main.cpp \
			PmergeMe.cpp \
			
OBJS    = $(SOURCES:.cpp=.o)

### RULES ###

all: $(NAME)

$(NAME): $(OBJS)
	$(CC) $(FLAGS) -o $@ $^

%.o: %.cpp *.hpp
	$(CC) $(FLAGS) -c -o $@ $<

clean:
	rm -rf $(OBJS)

fclean: clean
	rm -f $(NAME)

re: fclean all

.PHONY: all clean fclean re
#include "PmergeMe.hpp"

template<typename T>
PmergeMe<T>::PmergeMe()
{
	CLASS("Constructor", "PmergeMe");
}


template<typename T>
PmergeMe<T>::~PmergeMe()
{
	CLASS("Destructor", "PmergeMe");
}


template<typename T>
PmergeMe<T>::PmergeMe(const PmergeMe<T>& other)
{
	CLASS("Constructor by copy", "PmergeMe");
	if (this == &other)
		return ;
}


template<typename T>
PmergeMe<T>& PmergeMe<T>::operator= (const PmergeMe<T>& other)
{
	CLASS("Operand = Constructor", "PmergeMe");
	if (this == &other)
		return (*this);
	return (*this);
}

void	print_main(std::list<int> v)
{
	std::cout << "\nMAINCHIAN\n";
	std::list<int>::iterator it;
	std::list<int>::iterator ite;
	it = v.begin();
	ite = v.end();
	while (it != ite)
	{
		std::cout << (*it) << '\n';
		it++;
	}
}


template<typename T>
void PmergeMe<T>::createStack(char **tab, int size)
{
    for (int i = 0; i < size; i++) {
        try {
            int num = std::stoi(tab[i]);
            this->Numbers.push_back(num);
        } catch (const std::invalid_argument& e) {
            std::cerr << "Invalid argument: " << tab[i] << std::endl;
        } catch (const std::out_of_range& e) {
            std::cerr << "Argument out of range: " << tab[i] << std::endl;
        }
    }
	
	std::list<int> double_check;

	std::list<int>::iterator it;
	std::list<int>::iterator ite;
	it = Numbers.begin();
	ite = Numbers.end();
	while (it != ite)
	{
		if (std::find(double_check.begin(), double_check.end(), *it) != double_check.end())
		{
			std::cerr << "Multiple iterations of the number " << *it << std::endl;
			throw PmergeMe::Doubles();
		}
		double_check.push_back(*it);
		it++;
	}
	print_main(this->Numbers);
}

template<typename T>
void PmergeMe<T>::createPairs()
{
	// Iter
	// main_it = numbers.begin();
	// main_ite = numbers.end();
	// main_ite_plus_one = ++numbers.end();
	// main_ite_minus_one = --numbers.end();
	// int 	a;
	// int	b;

	// while (main_it != main_ite && main_it != main_ite_minus_one)
	// {
	// 	a = *main_it;
	// 	++main_it;
	// 	if (main_it != main_ite_plus_one)
	// 		b = *main_it;
	// 	else
	// 		b = -42;
	// 	// std::cout << "A is = " << a << " and B is = " << b << std::endl;
	// 	v.push_back(std::pair<int, int>(a, b));
	// 	++main_it;
	// }

	// int IMPAIR = 0;
	// if (main_it == main_ite_minus_one)
	// 	IMPAIR = *(main_ite_minus_one);
}

template<typename T>
const char* PmergeMe<T>::Doubles::what() const throw()
{
	return ("There are duplicates args.");
}#ifndef PMERGEME_HPP
# define PMERGEME_HPP

# include <iostream>
# include <iostream>
# include <vector>
# include <ctime>
# include <list>
# include <algorithm>
# include <exception>

# ifndef CLASS
// #  define CLASS(x, y) std::cout << ""
#  define CLASS(x, y) std::cout << "Called " << x << " of class " << y << std::endl
# endif

// template<typename T>
// 	class Iter
// {
// 	public:
// 	typename T::iterator		_Start;
// 	typename T::iterator		_End;
// 	typename T::iterator		_PrevOfEnd;
// 	typename T::iterator		_NextOfEnd;
// };

template<typename T>
class PmergeMe
{
	private:
		int					Impair;
		T					Cont;
		std::list<int>		Numbers;
		// Iter<T>				It;
	protected:

	public:
		PmergeMe();
		~PmergeMe();
		PmergeMe(const PmergeMe&);
		PmergeMe& operator= (const PmergeMe&);
		void	createStack(char **, int);
		void	createPairs();

		class Doubles: public std::exception
		{
			const char* what() const throw();
		};
};

void	print_main(T<int> v);


#endif
#include <iostream>
#include <vector>
#include <ctime>
#include <list>
#include <algorithm>
#include "PmergeMe.hpp"

void	print(T<std::pair<int, int> > v)
{
	return ;
	std::cout << "\n hey \n";

	T<std::pair<int, int> >::iterator it;
	T<std::pair<int, int> >::iterator ite;
	it = v.begin();
	ite = v.end();
	while (it != ite)
	{
		std::cout << (*it).first << " and " << (*it).second << '\n';
		it++;
	}
}

int main(int argc, char **argv)
{
	PmergeMe<T<std::pair<int, int>>> s;

	s.createStack(&argv[1], argc - 1);

	T<std::pair<int, int> > v;
	T<std::pair<int, int> >::iterator it;
	T<std::pair<int, int> >::iterator ite;
    T<int> numbers;
	T<int>::iterator main_it;
	T<int>::iterator main_ite;
	T<int>::iterator main_ite_plus_one;
	T<int>::iterator main_ite_minus_one;


    for (int i = 1; i < argc; i++) {
        try {
            int num = std::stoi(argv[i]);
            numbers.push_back(num);
        } catch (const std::invalid_argument& e) {
            std::cerr << "Invalid argument: " << argv[i] << std::endl;
        } catch (const std::out_of_range& e) {
            std::cerr << "Argument out of range: " << argv[i] << std::endl;
        }
    }
	//double check
	{
		T<int> double_check;

		main_it = numbers.begin();
		main_ite = numbers.end();
		while (main_it != main_ite)
		{
			if (std::find(double_check.begin(), double_check.end(), *main_it) != double_check.end())
			{
				std::cerr << "Multiple iterations of the number " << *main_it << std::endl;
				return (1);
			}
			double_check.push_back(*main_it);
			main_it++;
		}
	}
	print_main(numbers);
	return (0);
	// print_main(numbers);
	main_it = numbers.begin();
	main_ite = numbers.end();
	main_ite_plus_one = ++numbers.end();
	main_ite_minus_one = --numbers.end();
	int 	a;
	int	b;

	while (main_it != main_ite && main_it != main_ite_minus_one)
	{
		a = *main_it;
		++main_it;
		if (main_it != main_ite_plus_one)
			b = *main_it;
		else
			b = -42;
		// std::cout << "A is = " << a << " and B is = " << b << std::endl;
		v.push_back(std::pair<int, int>(a, b));
		++main_it;
	}

	int IMPAIR = 0;
	if (main_it == main_ite_minus_one)
		IMPAIR = *(main_ite_minus_one);
	// print(v);
	it = v.begin();
	ite = v.end();
	while (it != ite)
	{
		// std::cout << (*it).first << " and " << (*it).second << '\n';
		if ((*it).first > (*it).second)
			std::swap((*it).first, (*it).second);
		it++;
	}
	T<std::pair<int, int> > map;
	T<std::pair<int, int> >::iterator map_it;
	T<std::pair<int, int> >::iterator map_ite;
	T<std::pair<int, int> >::iterator map_ite_minus_one;
	
	map_it = map.begin();
	map_ite = --map.end();
	map.insert(map_it, *v.begin());
	v.erase(v.begin());
	map.push_back(*v.begin());
	v.erase(v.begin());
	it = v.begin();
	ite = v.end();
	if ((*map.begin()).first > (*(--map.end())).first)
		std::swap((*map.begin()), (*(--map.end())));
	while (it != ite)
	{
		if (map.size() > 1)
		{
			map_it = --map.begin();
			map_ite = --map.end();
			while ((*it).first < (*(map_ite)).first && map_ite != map_it)
			{
				map_ite--;
			}
			map.insert(++map_ite, *it);
		}
		v.erase(it);
		it = v.begin();
		ite = v.end();

	}
	T<int> main_chain;
	// print(map);
	map_it = map.begin();
	map_ite = map.end();
	while (map_it != map_ite)
	{
		main_chain.push_back((*map_it).first);
		map_it++;
	}
	// print_main(main_chain);
	if (IMPAIR)
	{
			main_it = main_chain.begin();
			main_ite = --main_chain.end();
			while (IMPAIR < *(main_ite) && main_ite != main_it)
			{
				main_ite--;
			}
			main_chain.insert(++main_ite, IMPAIR);
	}
	it = map.begin();
	ite = map.end();

	while (it != ite)
	{
			main_it = main_chain.begin();
			main_ite = --main_chain.end();
			while ((*it).second < *(main_ite) && main_ite != main_it)
			{
				main_ite--;
			}
			main_chain.insert(++main_ite, (*it).second);
		it++;
	}
	print_main(main_chain);
}

/*
#include <iostream>
#include <vector>
#include <ctime>
#include <list>
#include <algorithm>


void	print(std::list<std::pair<int, int> > v)
{
	return ;
	std::cout << "\n hey \n";

	std::list<std::pair<int, int> >::iterator it;
	std::list<std::pair<int, int> >::iterator ite;
	it = v.begin();
	ite = v.end();
	while (it != ite)
	{
		std::cout << (*it).first << " and " << (*it).second << '\n';
		it++;
	}
}

void	print_main(std::list<int> v)
{
	// return ;
	std::cout << "\nMAINCHIAN\n";
	std::list<int>::iterator it;
	std::list<int>::iterator ite;
	it = v.begin();
	ite = v.end();
	while (it != ite)
	{
		std::cout << (*it) << '\n';
		it++;
	}
}

int main(int argc, char **argv)
{
	std::list<std::pair<int, int> > v;
	std::list<std::pair<int, int> >::iterator it;
	std::list<std::pair<int, int> >::iterator ite;
	std::list<int>::iterator main_it;
	std::list<int>::iterator main_ite;
	std::list<int>::iterator main_ite_plus_one;
	std::list<int>::iterator main_ite_minus_one;




	// std::srand(std::time(NULL));
	// std::pair<int, int> a;

	// for (size_t i = 0; i < 5; i++)
	// {
	// 	v.push_back(std::pair<int, int>(std::rand() % 10000, std::rand() % 1000));
	// }





    std::list<int> numbers;


    for (int i = 1; i < argc; i++) {
        try {
            int num = std::stoi(argv[i]);
            numbers.push_back(num);
        } catch (const std::invalid_argument& e) {
            std::cerr << "Invalid argument: " << argv[i] << std::endl;
        } catch (const std::out_of_range& e) {
            std::cerr << "Argument out of range: " << argv[i] << std::endl;
        }
    }
	//double check
	{
		std::list<int> double_check;

		main_it = numbers.begin();
		main_ite = numbers.end();
		while (main_it != main_ite)
		{
			if (std::find(double_check.begin(), double_check.end(), *main_it) != double_check.end())
			{
				std::cerr << "Multiple iterations of the number " << *main_it << std::endl;
				return (1);
			}
			double_check.push_back(*main_it);
			main_it++;
		}
	}

	// print_main(numbers);
	main_it = numbers.begin();
	main_ite = numbers.end();
	main_ite_plus_one = ++numbers.end();
	main_ite_minus_one = --numbers.end();
	int 	a;
	int	b;

	while (main_it != main_ite && main_it != main_ite_minus_one)
	{
		a = *main_it;
		++main_it;
		if (main_it != main_ite_plus_one)
			b = *main_it;
		else
			b = -42;
		// std::cout << "A is = " << a << " and B is = " << b << std::endl;
		v.push_back(std::pair<int, int>(a, b));
		++main_it;
	}

	int IMPAIR = 0;
	if (main_it == main_ite_minus_one)
		IMPAIR = *(main_ite_minus_one);
	// print(v);
	it = v.begin();
	ite = v.end();
	while (it != ite)
	{
		// std::cout << (*it).first << " and " << (*it).second << '\n';
		if ((*it).first > (*it).second)
			std::swap((*it).first, (*it).second);
		it++;
	}
	std::list<std::pair<int, int> > map;
	std::list<std::pair<int, int> >::iterator map_it;
	std::list<std::pair<int, int> >::iterator map_ite;
	std::list<std::pair<int, int> >::iterator map_ite_minus_one;
	
	map_it = map.begin();
	map_ite = --map.end();
	map.insert(map_it, *v.begin());
	v.erase(v.begin());
	map.push_back(*v.begin());
	v.erase(v.begin());
	it = v.begin();
	ite = v.end();
	if ((*map.begin()).first > (*(--map.end())).first)
		std::swap((*map.begin()), (*(--map.end())));
	while (it != ite)
	{
		if (map.size() > 1)
		{
			map_it = --map.begin();
			map_ite = --map.end();
			while ((*it).first < (*(map_ite)).first && map_ite != map_it)
			{
				map_ite--;
			}
			map.insert(++map_ite, *it);
		}
		v.erase(it);
		it = v.begin();
		ite = v.end();

	}
	std::list<int> main_chain;
	// print(map);
	map_it = map.begin();
	map_ite = map.end();
	while (map_it != map_ite)
	{
		main_chain.push_back((*map_it).first);
		map_it++;
	}
	// print_main(main_chain);
	if (IMPAIR)
	{
			main_it = main_chain.begin();
			main_ite = --main_chain.end();
			while (IMPAIR < *(main_ite) && main_ite != main_it)
			{
				main_ite--;
			}
			main_chain.insert(++main_ite, IMPAIR);
	}
	it = map.begin();
	ite = map.end();

	while (it != ite)
	{
			main_it = main_chain.begin();
			main_ite = --main_chain.end();
			while ((*it).second < *(main_ite) && main_ite != main_it)
			{
				main_ite--;
			}
			main_chain.insert(++main_ite, (*it).second);
		it++;
	}
	print_main(main_chain);
}

*/